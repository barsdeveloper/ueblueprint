import CalculatedType from "./CalculatedType"
import GuidEntity from "./GuidEntity"
import IEntity from "./IEntity"
import IntegerEntity from "./IntegerEntity"
import LinearColorEntity from "./LinearColorEntity"
import LocalizedTextEntity from "./LocalizedTextEntity"
import ObjectReferenceEntity from "./ObjectReferenceEntity"
import PinReferenceEntity from "./PinReferenceEntity"
import RotatorEntity from "./RotatorEntity"
import SimpleSerializationRotatorEntity from "./SimpleSerializationRotatorEntity"
import SimpleSerializationVectorEntity from "./SimpleSerializationVectorEntity"
import TypeInitialization from "./TypeInitialization"
import UnionType from "./UnionType"
import Utility from "../Utility"
import VectorEntity from "./VectorEntity"

/** @typedef {import("./TypeInitialization").AnyValue} AnyValue */

/** @template {AnyValue} T */
export default class PinEntity extends IEntity {

    static #typeEntityMap = {
        "/Script/CoreUObject.LinearColor": LinearColorEntity,
        "/Script/CoreUObject.Rotator": RotatorEntity,
        "/Script/CoreUObject.Vector": VectorEntity,
        "bool": Boolean,
        "exec": String,
        "int": IntegerEntity,
        "name": String,
        "real": Number,
        "string": String,
    }
    static #alternativeTypeEntityMap = {
        "/Script/CoreUObject.Vector": SimpleSerializationVectorEntity,
        "/Script/CoreUObject.Rotator": SimpleSerializationRotatorEntity,
    }
    static lookbehind = "Pin"
    static attributes = {
        PinId: GuidEntity,
        PinName: "",
        PinFriendlyName: new TypeInitialization(new UnionType(LocalizedTextEntity, String), false, null),
        PinToolTip: new TypeInitialization(String, false, ""),
        Direction: new TypeInitialization(String, false, ""),
        PinType: {
            PinCategory: "",
            PinSubCategory: "",
            PinSubCategoryObject: ObjectReferenceEntity,
            PinSubCategoryMemberReference: null,
            PinValueType: null,
            ContainerType: ObjectReferenceEntity,
            bIsReference: false,
            bIsConst: false,
            bIsWeakPointer: false,
            bIsUObjectWrapper: false,
            bSerializeAsSinglePrecisionFloat: false,
        },
        LinkedTo: new TypeInitialization([PinReferenceEntity], false),
        DefaultValue:
            new CalculatedType(
                /** @param {PinEntity} pinEntity */
                pinEntity => new TypeInitialization(
                    PinEntity.getEntityType(pinEntity.getType(), true) ?? String,
                    false,
                    undefined,
                    true
                )
            ),
        AutogeneratedDefaultValue: new TypeInitialization(String, false),
        DefaultObject: new TypeInitialization(ObjectReferenceEntity, false, null),
        PersistentGuid: GuidEntity,
        bHidden: false,
        bNotConnectable: false,
        bDefaultValueIsReadOnly: false,
        bDefaultValueIsIgnored: false,
        bAdvancedView: false,
        bOrphanedPin: false,
    }

    static getEntityType(typeString, alternative = false) {
        const [entity, alternativeEntity] = [this.#typeEntityMap[typeString], this.#alternativeTypeEntityMap[typeString]]
        return alternative && alternativeEntity !== undefined
            ? alternativeEntity
            : entity
    }

    constructor(values = {}) {
        super(values)
        /** @type {GuidEntity} */ this.PinId
        /** @type {String} */ this.PinName
        /** @type {LocalizedTextEntity | String} */ this.PinFriendlyName
        /** @type {String} */ this.PinToolTip
        /** @type {String} */ this.Direction
        /**
         * @type {{
         *     PinCategory: String,
         *     PinSubCategory: String,
         *     PinSubCategoryObject: ObjectReferenceEntity,
         *     PinSubCategoryMemberReference: any,
         *     PinValueType: String,
         *     ContainerType: ObjectReferenceEntity,
         *     bIsReference: Boolean,
         *     bIsConst: Boolean,
         *     bIsWeakPointer: Boolean,
         *     bIsUObjectWrapper: Boolean,
         *     bSerializeAsSinglePrecisionFloat: Boolean,
         * }}
         */ this.PinType
        /** @type {PinReferenceEntity[]} */ this.LinkedTo
        /** @type {T} */ this.DefaultValue
        /** @type {String} */ this.AutogeneratedDefaultValue
        /** @type {ObjectReferenceEntity} */ this.DefaultObject
        /** @type {GuidEntity} */ this.PersistentGuid
        /** @type {Boolean} */ this.bHidden
        /** @type {Boolean} */ this.bNotConnectable
        /** @type {Boolean} */ this.bDefaultValueIsReadOnly
        /** @type {Boolean} */ this.bDefaultValueIsIgnored
        /** @type {Boolean} */ this.bAdvancedView
        /** @type {Boolean} */ this.bOrphanedPin
    }

    getType() {
        if (this.PinType.PinCategory == "struct" || this.PinType.PinCategory == "object") {
            return this.PinType.PinSubCategoryObject.path
        }
        return this.PinType.PinCategory
    }

    getDisplayName() {
        let matchResult = null
        if (
            this.PinToolTip
            // Match up until the first \n excluded or last character
            && (matchResult = this.PinToolTip.match(/\s*(.+?(?=\n)|.+\S)\s*/))
        ) {
            return Utility.formatStringName(matchResult[1])
        }
        return Utility.formatStringName(this.PinName)
    }

    /** @param {PinEntity} other */
    copyTypeFrom(other) {
        this.PinType.PinCategory = other.PinType.PinCategory
        this.PinType.PinSubCategory = other.PinType.PinSubCategory
        this.PinType.PinSubCategoryObject = other.PinType.PinSubCategoryObject
        this.PinType.PinSubCategoryMemberReference = other.PinType.PinSubCategoryMemberReference
        this.PinType.PinValueType = other.PinType.PinValueType
        this.PinType.ContainerType = other.PinType.ContainerType
        this.PinType.bIsReference = other.PinType.bIsReference
        this.PinType.bIsConst = other.PinType.bIsConst
        this.PinType.bIsWeakPointer = other.PinType.bIsWeakPointer
        this.PinType.bIsUObjectWrapper = other.PinType.bIsUObjectWrapper
        this.PinType.bSerializeAsSinglePrecisionFloat = other.PinType.bSerializeAsSinglePrecisionFloat
    }

    getDefaultValue() {
        return this.DefaultValue
    }

    isExecution() {
        return this.PinType.PinCategory === "exec"
    }

    isHidden() {
        return this.bHidden
    }

    isInput() {
        return !this.bHidden && this.Direction != "EGPD_Output"
    }

    isOutput() {
        return !this.bHidden && this.Direction == "EGPD_Output"
    }

    isLinked() {
        return this.LinkedTo?.length > 0 ?? false
    }

    /**
     * @param {String} targetObjectName
     * @param {PinEntity} targetPinEntity
     */
    linkTo(targetObjectName, targetPinEntity) {
        /** @type {PinReferenceEntity[]} */
        this.LinkedTo
        const linkFound = this.LinkedTo?.find(pinReferenceEntity => {
            return pinReferenceEntity.objectName.toString() == targetObjectName
                && pinReferenceEntity.pinGuid.valueOf() == targetPinEntity.PinId.valueOf()
        })
        if (!linkFound) {
            (this.LinkedTo ?? (this.LinkedTo = [])).push(new PinReferenceEntity({
                objectName: targetObjectName,
                pinGuid: targetPinEntity.PinId,
            }))
            return true
        }
        return false
    }

    /**
     * @param {String} targetObjectName
     * @param {PinEntity} targetPinEntity
     */
    unlinkFrom(targetObjectName, targetPinEntity) {
        const indexElement = this.LinkedTo?.findIndex(pinReferenceEntity => {
            return pinReferenceEntity.objectName.toString() == targetObjectName
                && pinReferenceEntity.pinGuid.valueOf() == targetPinEntity.PinId.valueOf()
        })
        if (indexElement >= 0) {
            if (this.LinkedTo.length == 1) {
                this.LinkedTo = undefined
            } else {
                this.LinkedTo.splice(indexElement, 1)
            }
            return true
        }
        return false
    }

    getSubCategory() {
        return this.PinType.PinSubCategoryObject.path
    }
}
